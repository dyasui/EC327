<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>elimination – EC327 Game Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">
      EC327 Game Theory
      </li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">EC327 Game Theory</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Slides</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Slides/01Intro/01-main.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Slides/02SequentialGames/02-main.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sequential Games</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Slides/03SimultaneousGames/03-main.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Simultaneous Games</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Activities</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../activities/01GuessTwoThirds/GuessTwoThirds.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Guessing Two Thirds of the Average</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../activities/02SurvivorFlags/SurvivorFlags.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Survivor Flags</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="the-problem-of-finding-nash-equilibria" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-of-finding-nash-equilibria">The Problem of Finding Nash Equilibria</h2>
<div class="incremental">
<ul class="incremental">
<li><p>When we first discussed Nash Equilibria (which I’m going to start abbreviating as NEs), we found them by checking all of the strategy profiles in the game to see which of them were stable.</p></li>
<li><p>This is not a problem in a 2x2 game like we’ve been working with—but it gets much more time-consuming in games with more players and more strategies per player, not to mention the more complicated games we’ll look at later in the term.</p></li>
<li><p>We can make it easier to find NEs with a few useful shortcuts—such as eliminating entire strategies (not just strategy profiles) that can’t possibly be part of a NE.</p></li>
</ul>
</div>
<hr>
</section>
<section id="strict-dominance" class="level2">
<h2 class="anchored" data-anchor-id="strict-dominance">Strict Dominance</h2>
<div class="incremental">
<ul class="incremental">
<li><p>A strategy is said to be strictly dominated if there is some other strategy, in the same player’s strategy set, which provides that player a higher payoff, no matter what strategies the other players pick.</p>
<ul class="incremental">
<li>Another way to phrase it is that a strategy is strictly dominated if some other strategy is a better alternative for the player, no matter what other players do.</li>
</ul></li>
<li><p>Recall that, in the Prisoner’s Dilemma, both Guido and Luca prefer to Testify, no matter whether the other player Testified or kept Quiet: this means that Quiet is strictly dominated, , for both players.</p></li>
<li><p>It is not rational to play a strictly dominated strategy—meaning that in the Prisoner’s Dilemma, we can immediately deduce that neither player would play Quiet, and the only remaining strategy profile is (Testify, Testify).</p></li>
</ul>
</div>
<hr>
</section>
<section id="finding-nes-by-elimination" class="level2">
<h2 class="anchored" data-anchor-id="finding-nes-by-elimination">Finding NEs by Elimination</h2>
<div class="incremental">
<ul class="incremental">
<li>If all but one of each player’s strategies can be eliminated like this (leaving only a single strategy profile), then the remaining strategy profile is a NE.
<ul class="incremental">
<li>A strictly dominated strategy can never be part of a NE.</li>
</ul></li>
<li>However, it’s rare that a player has one strategy which strictly dominates all of their others from the very start, as in the Prisoner’s Dilemma. (This is called a strategy.)</li>
<li>Even if a player doesn’t have a strictly dominant strategy, we can still sometimes use elimination to find a NE, by using a process called <span class="hi">Iterated Elimination of Strictly Dominated Strategies (IESDS)</span>.</li>
</ul>
</div>
<hr>
</section>
<section id="commonly-known-rationality" class="level2">
<h2 class="anchored" data-anchor-id="commonly-known-rationality">Commonly Known Rationality</h2>
<div class="incremental">
<ul class="incremental">
<li>Let’s assume that, not only is every player rational, they all know that the other players are rational too.</li>
<li>This means that players can deduce which strategies the <strong>other</strong> players would never play.</li>
<li>And if a player can eliminate another player’s strategy, it may reveal additional strictly dominated strategies that can be eliminated.</li>
<li>Let’s see an <a href="https://www.youtube.com/watch?v=EZSx3zNZOaU">example</a>…</li>
</ul>
</div>
<hr>
</section>
<section id="example-iesds" class="level2">
<h2 class="anchored" data-anchor-id="example-iesds">Example: IESDS</h2>
<div class="incremental">
<ul class="incremental">
<li>In the game table above, there are no strictly domin strategies. ::: {.incremental}
<ul class="incremental">
<li><p>For Player 1, A is strictly dominated by B, but C is neither dominant nor dominated.</p></li>
<li><p>And for Player 2, a is strictly dominated by b, but c is also neither dominant nor dominated.</p>
<p>:::</p></li>
</ul></li>
<li>So, we could eliminate A and a, but we’d still have a 2x2 game left over.</li>
</ul>
</div>
<hr>
</section>
<section id="example-iesds-1" class="level2">
<h2 class="anchored" data-anchor-id="example-iesds-1">Example: IESDS</h2>
<div class="incremental">
<ul class="incremental">
<li>However, the assumption of Commonly Known Rationality allows Player 1 to <strong>deduce</strong> that Player 2 would never play a.</li>
<li>Player 1 can eliminate a, just like we did—and once they do, C is strictly dominated by B.</li>
<li>Player 2 can deduce all of this—and once they eliminate A, a, and C, b is strictly dominated by c.</li>
<li>This leaves us one strategy per player, and so the NE here is (B, c).</li>
</ul>
</div>
<hr>
</section>
<section id="flaws-of-iesds-the-deer-hunt" class="level2">
<h2 class="anchored" data-anchor-id="flaws-of-iesds-the-deer-hunt">Flaws of IESDS: the Deer Hunt</h2>
<div class="incremental">
<ul class="incremental">
<li>IESDS doesn’t always reveal a NE. The strategies involved in a NE don’t have to be strictly dominant—they just can’t be strictly dominat.</li>
<li>As an example, the Deer Hunt game (above) contains no strictly dominated strategies.</li>
<li>Even if IESDS doesn’t reveal a NE, it can still be useful for simplifying a game before applying other methods.</li>
</ul>
</div>
<hr>
</section>
<section id="order-doesnt-matter" class="level2">
<h2 class="anchored" data-anchor-id="order-doesnt-matter">Order Doesn’t Matter</h2>
<div class="incremental">
<ul class="incremental">
<li><strong>In IESDS</strong>, the order in which you eliminate strategies doesn’t matter. You’ll get the same result no matter how you do it—as long as you keep going to the end.</li>
<li>Consider this even larger game, and suppose we start by looking for Player 1’s strictly dominated strategies:</li>
</ul>
</div>
<hr>
</section>
<section id="order-doesnt-matter-1" class="level2">
<h2 class="anchored" data-anchor-id="order-doesnt-matter-1">Order Doesn’t Matter</h2>
<p>And now suppose we start by looking for Player 2’s strictly dominated strategies:</p>
<hr>
</section>
<section id="iesds-in-a-nutshell" class="level2">
<h2 class="anchored" data-anchor-id="iesds-in-a-nutshell">IESDS in a Nutshell</h2>
<div class="incremental">
<ul class="incremental">
<li>The process of IESDS can be summed up in three steps: [1.] Search for a strictly dominated strategy belonging to any player. If none exists, stop here: IESDS is completed. [2.] Eliminate (cross out) that strategy. Optionally, re-draw the game table without the eliminated strategy. [3.] Return to step 1.</li>
</ul>
</div>
<hr>
</section>
<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section"></h2>
<div class="incremental">
<ul class="incremental">
<li>In the game above, which strategy is strictly dominated?
<ol class="incremental" type="1">
<li>X</li>
<li>Y</li>
<li>Z</li>
<li>x</li>
<li>y</li>
</ol></li>
</ul>
</div>
<hr>
</section>
<section id="section-1" class="level2">
<h2 class="anchored" data-anchor-id="section-1"></h2>
<div class="incremental">
<ul class="incremental">
<li>Strategy Z is strictly dominated. Which strategy strictly dominates it?
<ol class="incremental" type="1">
<li>X</li>
<li>Y</li>
<li>Both X and Y</li>
</ol></li>
</ul>
</div>
<hr>
</section>
<section id="section-2" class="level2">
<h2 class="anchored" data-anchor-id="section-2"></h2>
<div class="incremental">
<ul class="incremental">
<li>Perform IESDS all the way to completion. What does IESDS tell you about the NE of this game?
<ol class="incremental" type="1">
<li>The NE is (X, x).</li>
<li>The NE is (X, y).</li>
<li>The NE is (Y, y).</li>
<li>The NE is (Y, z).</li>
<li>IESDS by itself does not reveal the NE of this game.</li>
</ol></li>
</ul>
</div>
<hr>
</section>
<section id="other-elimination-methods-weakly-dominated-strategies" class="level2">
<h2 class="anchored" data-anchor-id="other-elimination-methods-weakly-dominated-strategies">Other Elimination Methods: Weakly Dominated Strategies</h2>
<div class="incremental">
<ul class="incremental">
<li>It is also possible to find Nash Equilibria by eliminating <span class="hi">weakly dominated</span> strategies (strategies for which there is an alternative that is never worse, and sometimes better).</li>
<li>We will not spend a lot of time on this method, because it has two serious flaws: [1.] It is possible for a Nash Equilibrium to involve playing a weakly dominated strategy. IEWDS may therefore eliminate actual Nash Equilibria. [2.] Unlike IESDS, the order in which you eliminate weakly dominated strategies matters: you may get different results from different orders of elimination.</li>
</ul>
</div>
<hr>
</section>
<section id="example-why-weak-dominance-is-not-useful" class="level2">
<h2 class="anchored" data-anchor-id="example-why-weak-dominance-is-not-useful">Example: Why Weak Dominance is Not Useful</h2>
<p>In the game below, B is weakly dominated for both players.</p>
<div class="incremental">
<ul class="incremental">
<li>If we eliminate the weakly dominated strategy for both players, then the only remaining strategy profile is (A, A)—and this is a Nash equilibrium.</li>
<li>However, (B, B) is also a Nash equilibrium: both players get payoff 1, and neither can improve that payoff by changing their own strategy. We failed to find this equilibrium by eliminating weakly dominated strategies.</li>
</ul>
</div>
<hr>
</section>
<section id="another-example-why-weak-dominance-is-not-useful" class="level2">
<h2 class="anchored" data-anchor-id="another-example-why-weak-dominance-is-not-useful">Another Example: Why Weak Dominance is Not Useful</h2>
<p>In the game below, M and R are weakly dominated.</p>
<div class="incremental">
<ul class="incremental">
<li>If we begin by eliminating R, then afterwards, M and B are both weakly dominated, and we would eliminate them, leaving only (T, L).</li>
</ul>
</div>
<hr>
</section>
<section id="another-example-why-weak-dominance-is-not-useful-1" class="level2">
<h2 class="anchored" data-anchor-id="another-example-why-weak-dominance-is-not-useful-1">Another Example: Why Weak Dominance is Not Useful</h2>
<div class="incremental">
<ul class="incremental">
<li>However, if we begin by eliminating M, then T and R are both weakly dominated, and if we eliminate them, we are left with only (B, L).</li>
<li>Not only does the outcome of IEWDS depend on what we eliminate first, it still fails to find a <strong>third</strong> Nash equilibrium, which is (B, R).</li>
</ul>
</div>
<hr>
</section>
<section id="other-elimination-methods-non-best-responses" class="level2">
<h2 class="anchored" data-anchor-id="other-elimination-methods-non-best-responses">Other Elimination Methods: Non-Best-Responses</h2>
<div class="incremental">
<ul class="incremental">
<li>Generally speaking, we can eliminate any strategy which is not rational to play in a NE.</li>
<li>It’s never rational to play strictly dominated strategies, but it’s sometimes rational to play weakly dominated strategies.</li>
<li>There are other categories of non-rational strategies:</li>
<li>A strategy is a <span class="hi">non-best-response</span> or <span class="hi">non-rationalizable strategy</span> if and only if, regardless of what the other players choose, it never provides the best possible payoff.</li>
<li>I like to describe non-rationalizable strategies as strategies that you’d have to be crazy to think were a good idea, i.e.&nbsp;you can’t rationalize playing them.</li>
</ul>
</div>
<hr>
</section>
<section id="strictly-dominated-vs.-non-best-response" class="level2">
<h2 class="anchored" data-anchor-id="strictly-dominated-vs.-non-best-response">Strictly Dominated vs.&nbsp;Non-Best-Response}</h2>
<div class="incremental">
<ul class="incremental">
<li>Non-rationalizability is very similar to strict dominance, but here’s the difference:</li>
<li>Strict dominance is pairwise: a strategy <span class="math inline">\(s\)</span> dominates another, <span class="math inline">\(s'\)</span>, if <span class="math inline">\(s\)</span> specifically always gives a better payoff than <span class="math inline">\(s'\)</span>.</li>
<li>Non-rationalizability is a property of a single strategy: for a strategy to be non-rationalizable, it means that there is always <em>some</em> option that gives a better payoff—but the better option doesn’t always have to be the same strategy.</li>
<li>To put it another way: strategy <span class="math inline">\(s\)</span> is not a best response if there is always <strong>some strategy* which is better. To be strictly dominated, there must be </strong>one particular strategy** which is always better.</li>
</ul>
</div>
<hr>
</section>
<section id="example-non-best-responses" class="level2">
<h2 class="anchored" data-anchor-id="example-non-best-responses">Example: Non-Best-Responses}</h2>
<p>In the game below, there are no strictly dominated strategies, meaning that IESDS will not do anything to simplify it.</p>
<div class="incremental">
<ul class="incremental">
<li>However, we can see that B is non-rationalizable for Player 1: regardless of whether Player 2 chooses a, b, or c, Player 1 is better off playing either A or C.</li>
<li>Also, b is non-rationalizable for Player 2.</li>
</ul>
</div>
<hr>
</section>
<section id="another-example-non-best-responses" class="level2">
<h2 class="anchored" data-anchor-id="another-example-non-best-responses">Another Example: Non-Best-Responses</h2>
<hr>
</section>
<section id="iterated-elimination-of-non-best-responses" class="level2">
<h2 class="anchored" data-anchor-id="iterated-elimination-of-non-best-responses">Iterated Elimination of Non-Best-Responses</h2>
<div class="incremental">
<ul class="incremental">
<li>It is not rational to play a non-best-response strategy in a pure-strategy context. (As we’ll see much later, it’s more complicated in a mixed-strategy context).</li>
<li>Any strictly dominated strategy is also not a best response, but not all NBR strategies are strictly dominated.</li>
<li>Because of this, if we eliminate non-best-responses, using the same steps as IESDS, this process will always eliminate the same strategies, and it may eliminate even more!</li>
<li>This process is, naturally, called Iterative Elimination of Non-Best-Responses (IENBR).</li>
</ul>
</div>
<hr>
</section>
<section id="example-ienbr" class="level2">
<h2 class="anchored" data-anchor-id="example-ienbr">Example: IENBR</h2>
<p>Returning to this same example, we can start by eliminating B.</p>
<div class="incremental">
<ul class="incremental">
<li>Once we do this, we can now see that b and c are non-rationalizable, and eliminate them.</li>
<li>Finally, we can see that B is non-rationalizable and eliminate it, leaving only the strategy profile (C, a), which is the Nash equilibrium of this game.</li>
</ul>
</div>
<hr>
</section>
<section id="another-example-ienbr" class="level2">
<h2 class="anchored" data-anchor-id="another-example-ienbr">Another Example: IENBR</h2>
<hr>
</section>
<section id="iclicker-q4" class="level2">
<h2 class="anchored" data-anchor-id="iclicker-q4">iClicker Q4</h2>
<div class="incremental">
<ul class="incremental">
<li>After eliminating Z, which is strictly dominated, what strategy is a non-best-response?
<ol class="incremental" type="1">
<li>X</li>
<li>Y</li>
<li>Z</li>
<li>y</li>
<li>z</li>
</ol></li>
</ul>
</div>
<hr>
</section>
<section id="iclicker-q5" class="level2">
<h2 class="anchored" data-anchor-id="iclicker-q5">iClicker Q5</h2>
<div class="incremental">
<ul class="incremental">
<li>If we complete IENBR on this game table, what strategy profile is left at the end?
<ol class="incremental" type="1">
<li>(X, x)</li>
<li>(X, z)</li>
<li>(Y, x)</li>
<li>(Y, z)</li>
<li>There is more than one strategy profile left.</li>
</ol></li>
</ul>
</div>
<hr>
</section>
<section id="failures-of-elimination-methods" class="level2">
<h2 class="anchored" data-anchor-id="failures-of-elimination-methods">Failures of Elimination Methods</h2>
<div class="incremental">
<ul class="incremental">
<li>There’s no guarantee that any particular game will contain strategies that are either strictly dominated or non-rationalizable.</li>
<li>Even when there are strategies we can eliminate, there may not be enough of them to find a NE just by elimination.</li>
<li>So why bother with this?</li>
<li>Even if elimination doesn’t immediately identify a NE, it can still be helpful to simplify the game before trying other methods.</li>
<li>Simplifying by elimination is <strong>especially</strong> useful when dealing with mixed strategies—which we’ll get to after the midterm.</li>
</ul>
</div>
<hr>
</section>
<section id="best-responses" class="level2">
<h2 class="anchored" data-anchor-id="best-responses">Best-Responses}</h2>
<div class="incremental">
<ul class="incremental">
<li>In this discussion of non-best-response strategies, we’ve sort of skipped over one thing: if a strategy is NOT a non-best-response, then logically, it must sometimes be a best response.</li>
<li>This is arguably an even more important concept—and one that we’ll get to tomorrow.</li>
</ul>
</div>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>