
# Backwards Induction

## Solving Sequential Games

Now that we have defined all the parts of what a sequential game is 
we can start to *solve* them.

. . .

  - A solution in our case will be a prediction of what [sequentially rational]{.hi} agents would do

---

## Solving the Kidnapping Game

![](figures/kidnapgame.png)

::: notes
  - If Vivica paid ransom, Guy would rather Release
  - If Vivica didn't pay, Guy would rather Kill
  - Knowing this, Vivica would Pay to avoid Orland being killed
  - Therefore, Guy should kidnap Orlando knowing that Vivica will pay and he can release Orlando
:::

---

## Solving the Kidnapping Game (step 1)

Let's start at the end (bottom) of the game:

. . .

  * If the ransom **has** already been paid, what should [Guy]{.red} do?

```{dot}
digraph D {
  Guy [color="red"];
  O1 [shape=plaintext,label="4\n1"];
  O2 [shape=plaintext,label="5\n3"];
  Guy->O1[label="Kill",arrowhead=none];
  Guy->O2[label="Release",arrowhead=none];
}
```

## Solving the Kidnapping Game (step 1)

Let's start at the end (bottom) of the game:

  * If the ransom **has not** been paid, what should [Guy]{.red} do?

```{dot}
digraph D {
  Guy [color="red"];
  O1 [shape=plaintext,label="4\n1"];
  O2 [shape=plaintext,label="5\n3"];
  Guy->O1[label="Kill",arrowhead=none,style="dashed"];
  Guy->O2[label="Release"];
}
```

---

## Solving the Kidnapping Game (step 2)

Let's start at the end (bottom) of the game:

  * If the ransom **has not** been paid, what should [Guy]{.red} do?

```{dot}
digraph D {
  Guy [color="red"];
  O1 [shape=plaintext,label="2\n2"];
  O2 [shape=plaintext,label="1\n4"];
  Guy->O1[label="Kill",arrowhead=none];
  Guy->O2[label="Release",arrowhead=none];
}
```

## Solving the Kidnapping Game (step 2)

Let's start at the end (bottom) of the game:

  * If the ransom **has not** been paid, what should [Guy]{.red} do?

```{dot}
digraph D {
  Guy [color="red"];
  O1 [shape=plaintext,label="2\n2"];
  O2 [shape=plaintext,label="1\n4"];
  Guy->O1[label="Kill"];
  Guy->O2[label="Release",arrowhead=none,style="dashed"];
}
```

---

## Solving the Kidnapping Game (step 3)

:::: {.columns}

::: {.column width=30%}
Now, let's move one level up

  * What should [Vivica]{.blue} believe about [Guy]{.red}'s actions if she **pays** vs **does not pay** the ransom?

  * Which action should she take?

:::

::: {.column width=70%}
```{dot}
digraph D {
  node [label="Guy",color="red"]; GuyPay; GuyNo;
  Vivica [label="Vivica",color="blue"]; 
  O1 [shape=plaintext,label="4\n1"];
  O2 [shape=plaintext,label="5\n3"];
  O3 [shape=plaintext,label="2\n2"];
  O4 [shape=plaintext,label="1\n4"];

  Vivica->GuyPay[label="Pay",arrowhead=none];
  Vivica->GuyNo[label="Don't",arrowhead=none];

  GuyPay->O1[label="Kill",arrowhead=none,style="dashed"];
  GuyPay->O2[label="Release"];

  GuyNo->O3[label="Kill"];
  GuyNo->O4[label="Release",arrowhead=none,style="dashed"];
}
```

:::

::::

## Solving the Kidnapping Game (step 3)

:::: {.columns}

::: {.column width=30%}
Now, let's move one level up

  * What should [Vivica]{.blue} believe about [Guy]{.red}'s actions if she **pays** vs **does not pay** the ransom?

  * Which action should she take?

:::

::: {.column width=70%}
```{dot}
digraph D {
  node [label="Guy",color="red"]; GuyPay; GuyNo;
  Vivica [label="Vivica",color="blue"]; 
  O1 [shape=plaintext,label="4\n1"];
  O2 [shape=plaintext,label="5\n3"];
  O3 [shape=plaintext,label="2\n2"];
  O4 [shape=plaintext,label="1\n4"];

  Vivica->GuyPay[label="Pay"];
  Vivica->GuyNo[label="Don't",arrowhead=none,style="dashed"];

  GuyPay->O1[label="Kill",arrowhead=none,style="dashed"];
  GuyPay->O2[label="Release"];

  GuyNo->O3[label="Kill"];
  GuyNo->O4[label="Release",arrowhead=none,style="dashed"];
}
```
:::
::::

---

## Solving the Kidnapping Game (step 4)

Now what will happen if:

  * Guy is rational
  * Vivica *believes* Guy is rational and is rational herself
  * *Guy believes* that Vivica believes that he is rational

---

## Solving the Kidnapping Game (step 4)

```{dot}
digraph D {
  node [label="Guy",color="red"]; GuyPay; GuyNo; Guy;
  Vivica [label="Vivica",color="blue"]; 
  O1 [shape=plaintext,label="4\n1"];
  O2 [shape=plaintext,label="5\n3"];
  O3 [shape=plaintext,label="2\n2"];
  O4 [shape=plaintext,label="1\n4"];
  O5 [shape=plaintext,label="3\n5"];

  Guy->Vivica[label="Kidnap"];
  Guy->O5[label="Don't",arrowhead=none,style="dashed"];

  Vivica->GuyPay[label="Pay"];
  Vivica->GuyNo[label="Don't",arrowhead=none,style="dashed"];

  GuyPay->O1[label="Kill",arrowhead=none,style="dashed"];
  GuyPay->O2[label="Release"];

  GuyNo->O3[label="Kill"];
  GuyNo->O4[label="Release",arrowhead=none,style="dashed"];
}
```

---

## Backwards Induction (intuitively)

Let's outline the logical steps we used to solve this game:

::: {.incremental}

  * We were uncertain about what would happen in this game, because [Vivica]{.red}'s optimal strategy depended on what [Guy]{.blue} woud do

  * But after Vivica has chosen, [Guy]{.red} is the only player left and his action depends only on *his own preferences*

  * Knowing what [Guy]{.red} would choose allowed us to find [Vivica]{.blue}'s best response

  * Knowing what [Vivica]{.blue} would choose allowed us to find [Guy]{.red}'s best response
:::

## Backwards Induction defined

The method of looking at decisions in the future to decide what to do now is called [Backwards Induction]{.h} or [Rollback]{.h}

::: {.callout-tip}
## Definition ^[Dixit et al, pg 56]
... using [rollback]{.h} requires starting to think about what will happen at all the terminal nodes and literally "rolling back" through the tree to the initial node...
:::

---

## Backwards Induction defined

The method of looking at decisions in the future to decide what to do now is called [Backwards Induction]{.h} or [Rollback]{.h}

::: {.callout-tip}
## Definition ^[Dixit et al, pg 56]
When all players do *rollback analysis* to choose their optimal strategies, we call this set of strategies the [*rollback equilibrium*]{.h}^[aka subgame perfect equilibrium] of the game; the outcome that arises from playing these strategies is the [*rollback equilibrium outcome*]{.hi}
:::

---

## Kidnapping Game Solution

The [Rollback Equilibrium]{.h} is:

  * **{** ([Kidnap]{.red}, [Release]{.red}, [Kill]{.red}), ([Pay]{.blue}) **}**

::: {.incremental}
You should read this as:

  - Guy [Kidnaps]{.red} and will [Release]{.red} if Vivica [Pays]{.blue}, but will [Kill]{.red} if Vivica [Doesn't Pay]{.blue}

  - Vivica [Pays]{.blue} the ransom
:::

---

## Subgame perfect Nash equilibrium

Another term for the [rollback solution]{.hi} is [subgame perfect Nash equilibrium]{.hi}

  * Don't worry too much about the Nash part (we will revisit)

  * A [subgame]{.hi} refers to the way we broke up the larger game into smaller ones

---

## Extensive Form Survivor Flags

Let's consider a simplified version of the [Survivor Flags game](../../activities/02SurvivorFlags/SurvivorFlags.qmd):

  * Instead of 21 total flags, suppose there are only 5.

  * Instead of picking 1, 2, or 3, teams can only take 1 or 2 flags at a time.

. . .

How would we represent the [game tree]{.hi}?

---

## Extensive Form Survivor Flags

```{dot}
digraph D {
  node [label="Team 1",color="red"]; A1; A2; A3; A4; 
  node [label="Team 2",color="blue"]; B1; B2; B3;
  node [shape=plaintext,label="1 \n 0"]; O1; O5; O7; O8;
  node [shape=plaintext,label="0 \n 1"]; O2; O3; O4; O6;
  edge [arrowhead=none];

  A1->B1[label="1"];
  B1->A2[label="1"];
  A2->B3[label="1"];
  B3->O1[label="1"];
  B3->O2[label="2"];
  A2->O3[label="2"];
  B1->A3[label="2"];
  A3->O4[label="1"];
  A3->O5[label="2"];
  A1->B2[label="2"];
  B2->A4[label="1"];
  A4->O6[label="1"];
  A4->O7[label="2"];
  B2->O8[label="2"];
}
```

. . .

  * Try out our new method of [backwards induction]{.hi}

---

## Solving the simplified Survivor Flags

:::: {.columns}

::: {.column width=30%}
Let's take a look at the subgame after [Team 1]{.red} and [Team 2]{.blue} have each taken 1 flag:

  * What do you notice?
:::

::: {.column width=70%}
```{dot}
digraph D {
  node [label="Team 1",color="red"]; A1; A2; 
  node [label="Team 2",color="blue"]; B1; B3;
  node [shape=plaintext,label="1 \n 0"]; O1; 
  node [shape=plaintext,label="0 \n 1"]; O2; O3;
  edge [arrowhead=none];

  A1->B1[label="1"];
  B1->A2[label="1"];
  A2->B3[label="1"];
  B3->O1[label="1"];
  B3->O2[label="2"];
  A2->O3[label="2"];
}
```
:::
::::

---

## Solving the simplified Survivor Flags

:::: {.columns}

::: {.column width=30%}
[Team 1]{.red} is **indifferent** between taking 1 or 2 flags.

  * This allows for [multiple equilibria]{.hi}
:::

::: {.column width=70%}
```{dot}
digraph D {
  node [label="Team 1",color="red"]; A2; 
  node [label="Team 2",color="blue"]; B3;
  node [shape=plaintext,label="1 \n 0"]; O1; 
  node [shape=rectangle,color="black",label="0 \n 1"]; O2; O3;
  edge [arrowhead=none];

  A2->B3[label="1",arrowhead=normal];
  B3->O1[label="1",style="dashed"];
  B3->O2[label="2",arrowhead=normal];
  A2->O3[label="2"arrowhead=normal];
}
```
:::
::::

## Extensive Form Survivor Flags

```{dot}
digraph D {
  node [label="Team 1",color="red"]; A1; A2; A3; A4; 
  node [label="Team 2",color="blue"]; B1; B2; B3;
  node [shape=plaintext,label="1 \n 0"]; O1; O5; O7; O8;
  node [shape=plaintext,label="0 \n 1"]; O2; O3; O4; O6;
  edge [arrowhead=none];

  A1->B1[label="1",arrowhead=normal];
  B1->A2[label="1",arrowhead=normal];
  A2->B3[label="1",arrowhead=normal];
  B3->O1[label="1",style="dashed"];
  B3->O2[label="2",arrowhead=normal];
  A2->O3[label="2",arrowhead=normal];
  B1->A3[label="2",style="dashed"];
  A3->O4[label="1",style="dashed"];
  A3->O5[label="2",arrowhead=normal];
  A1->B2[label="2",style="dashed"];
  B2->A4[label="1",arrowhead=normal];
  A4->O6[label="1",style="dashed"];
  A4->O7[label="2",arrowhead=normal];
  B2->O8[label="2",arrowhead=normal];
}
```

---

## Three new concepts

  1. A list of *available strategies* for each player ^[could be very long]

  2. An *optimal strategy* for each player

     - A complete plan of action states a player's best choice at each node where she *could* make a decision ^[even if never reached in equilibrium]
  
  3. The path of play in [rollback equilibrium]{.hi} which combines optimal strategies for all players

